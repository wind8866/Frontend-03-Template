- [ ] 自己实现一个FakePromise
- [ ] 用promise实现一个ajax
```javascript
const promise = new Promise(function(resolve, reject)) {
    const value = 'value';
    if (false) {
        resolve(value);
    } else {
        reject(error);
    }
}

promise.then(funciton(value) {
    // success
}, function(error) {
    // error
})
```

Promise新建后会立即执行，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行。
```javascript
console.log(1);
const promise = new Promise(function(resolve, reject) {
    console.log(2);
    const value = 'value';
    if (true) {
        resolve(value);
    } else {
        reject(error);
    }
})
console.log(3);
promise.then(function(value) {
    // success
    console.log(4);
}, function(error) {
    // error
});
console.log(5);
setTimeout(function(){
    console.log(6);
}, 0);
// 依次返回：1、2、3、5、4、6
```

下面的代码p1和p2其实是并行执行。
p2返回一个Promise，那么p1的状态决定了p2的状态
```javascript
let moment = +(new Date());
const p1 = new Promise(function(resolve, reject) {
    setTimeout(() => {
        // 创建后立即执行，所以这里会在第三秒执行
        console.log(+(new Date()) - moment)
        reject(new Error('fail'))
    }, 3000)
});
const p2 = new Promise(function(resolve, reject) {
    setTimeout(() => resolve(p1), 1000)
});
p2.then(result => {
    console.log(result)
}).catch(error => {
    // p1和p2的大的定时器决定了此代码的执行时机
    console.log(error, +(new Date()) - moment);
})
```


then 方法返回一个新的Promise对象，如果then里面的方法是异步的，则回调函数会等待异步执行完成。